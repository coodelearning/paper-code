# 面向包设计

原文 [https://www.ardanlabs.com/blog/2017/02/package-oriented-design.html](https://www.ardanlabs.com/blog/2017/02/package-oriented-design.html)

非直译，有取舍

## 序
这篇文章仅仅是关于面向包设计理念中的一篇。如果你还没有看过下面这些内容，请先看看，有助于你理解本篇文章内容。

## 前
面向包设计的理念让开发者在一个 go 项目中确定包的组织和必须要遵守的设计准则。它定义了一个 go 项目应该是什么样的及怎么架构和分层一个 go 项目。它最终的目的是为了提高项目的易懂性、整洁和可讨论性，便于团队成员沟通。

面向包设计不局限于项目本身的结构，更多为了表达一个实现合理面向包设计的项目结构是多么的重要。下面我将介绍一个面向包设计的项目和之前提到过的相关的准则。

## 项目结构

每个公司都会有一个工具包的项目和不同业务的应用项目

### 工具包项目

考虑到工具包作为公司的一个标准类库，所以应该仅有一个。里面的所有包都需要设计为高可移植性。这些包可以在任何一个项目中都能使用，并且提供的都是很实用、具体的但又非常基础的功能。为了达到这样的目标，工具包项目不能有一个包依赖三方的 vendor。因为如果有包依赖三方包，那就得不断的构建编译随着那些三方包的更新。

同时也不建议把工具包项目的部分包直接复制到你的应用项目中，因为这样本身增加了你对这些包管理、更新的工作，当然你如果真这样做也没毛病。

### 应用项目

应用项目是包含了很多需要部署在一起的程序集，包括服务、命令行工具和后台运行的程序。每个项目都对应一个含有其所有源代码的仓库，包括所有依赖的三方包。你需要几个应用项目，视情况以你而定，当然是越少越好。

每个应用项目通常包含三个根文件夹，分别是 cmd，internal，vendor。在 internal 文件里也会包含 platform 文件夹，但是它和 internal 里其他的包有着不同的设计约束。

一个典型的应用项目结构应该是这样的：

```

github.com/servi-io/api
├── cmd/
│   ├── servi/
│   │   ├── cmdupdate/
│   │   ├── cmdquery/
│   │   └── servi.go
│   └── servid/
│       ├── routes/
│       │   └── handlers/
│       ├── tests/
│       └── servid.go
├── internal/
│   ├── attachments/
│   ├── locations/
│   ├── orders/
│   │   ├── customers/
│   │   ├── items/
│   │   ├── tags/
│   │   └── orders.go
│   ├── registrations/
│   └── platform/
│       ├── crypto/
│       ├── mongo/
│       └── json/
└── vendor/
    ├── github.com/
    │   ├── ardanlabs/
    │   ├── golang/
    │   ├── prometheus/
    └── golang.org/
```

#### vendor/

vendor文件夹包含了所有依赖的三方的源代码，它是go项目最早的依赖包的管理方式。目前大都用的go mod的依赖包管理，相对vendor，能指定版本，并且你不用特意手动下载更新依赖包，通过正常的go build, go run命令会自动处理。这样会减少项目本身的容量大小。

> 这里不过多介绍go mod的用法和特性。

#### cmd/

项目中的所有的程序都需要放在`cmd/` 文件夹里。每个程序对应一个文件夹，文件夹的名称应该以程序的名称命名。一般在名称后面加上`d` 代表该程序是一个守护进程运行。每个文件夹必须有一个`main`包的源文件。


> 比如一个项目包含线上业务服务bizserver（提供restful API）、后台管理服务adminserver(供内部人员使用）和一个定时器timer（定时更新数据的状态）三个程序。`cmd`文件夹应该有三个对应的文件夹，并且每个文件夹下面都有一个`main`包的源文件，至于名称可以直接用main，也可以对应文件夹的名称。
>  每个文件夹下的源文件里的代码和业务逻辑基本没任何关系。比如rest ful的bizserver，里面仅包含router的配置和相关的handler。

#### internal/
需要被项目内部的程序导入的包，都应该放在`internal`文件夹下。该文件夹下的所有包及相应文件都有一个项目保护级别，即其他项目是不能导入这些包的，仅仅是该项目内部使用。
#### internal/platform/
这些包是比较基础但又提供了很特殊的功能，比如数据库、日志、用户验证等功能。
### 验证包的设计
面向包设计的准则可以验证项目中包设计的是否合理，下面这些步骤可以帮你发现包设计的问题。
#### 包的位置

* `kit`
被不同应用项目导入的基础包

* `cmd`
支持编译不同二进制程序的包，比如Restful路由程序，需要相关router, handler包和main入口包。

* `internal`
项目内部使用的包，包括crud, service(facada)和业务逻辑的包。
* `internal/platform`
为本项目内部使用的基础包，包括数据库、认证和序列化等操作的包。
#### 依赖包导入
* 根据业务合理设计包的粒度。
* 在一个包中导入另一个包中的类型，是不合适的。
* 在同一个目录下的包互相导入，是不合适的。
* 如果真有上面的需求
1、请检查你对领域知识的理解、领域模型设计和包的设计。
2、将被导入的包移动到你的包里面。
* `internal/`中的包不能导入`cmd/`中的包。
* `internal/platform/`中的包不能导入`cmd/`, `internal/`中的包。
#### 项目层的策略
比如给restful api的handler写中间件、定时更新等策略。

在`Kit`, `internal/platform/`中是不允许写这些策略的，也不允许日志的打印。在这里数据库的配置、日志文件的配置应该和运行时环境的改变是低耦合的，可以通过环境变量来修改配置。

在`cmd/`, `internal/`是可以写中间件和定时器等。
#### 数据的发送和接受
* 在语意上要确定好一个类型发送和接受的方式，即值类型还是引用类型。
比如golang的http包中的Request结构体，在http中是以引用类型使用的。可以查看http包下面的server源码，里面包含了各种用法，如果你想自己写路由，server的几个函数和类型是必须要用的，这里不过多介绍。
* 如果你用一个接口类型的变量接收一个返回值，则更多的目的应该是调用接口的方法即行为，而不是值本身。如果不是这样，请直接用具体的类型。

#### 错误处理
错误处理包括错误信息的日志输出，分析和解决错误，并且保证程序能恢复如果发生了错误。
* `Kit`
不允许使用panic终止程序或抛出错误。

不允许再次包装错误信息，原本原样的把系统错误或框架的错误返回即可。

* `cmd/`
允许使用panic终止程序或抛出错误。

如果有错误发生且不处理，可以根据此时的业务或逻辑上下午包装一下错误，让更上层的处理错误的函数能知道是哪里抛出的错误。

当然大多数的错误都应该在这里处理。
* `internal/`
不允许使用panic终止程序或抛出错误。

如果有错误发生且不处理，可以根据此时的业务或逻辑上下午包装一下错误，让更上层的处理错误的函数能知道是哪里抛出的错误。

当然大多数的错误都应该在这里处理。
* `internal/platform/`
不允许使用panic终止程序或抛出错误。

不允许再次包装错误信息，原本原样的把系统错误或框架的错误返回即可。
